# 02 Domain Map and Representativeness Guarantee

This document explains how the domain map generated in Step02 ensures representative coverage of the repository, and how sampling strategies are designed to avoid biased or incomplete training data.

The domain map is generated by `scripts/02_build_domain_map.py` and stored in `data/extracted/domain_map.json`.

The design goal is **not** to reconstruct an exact call graph, but to produce a **traceable and extensible intermediate representation** that supports downstream QA and design-oriented data generation.

---

## 1. What Is the Domain Map

The domain map consists of four core components:

- **boundaries**  
  Chunk-level grouping by architectural layer  
  (`controller`, `service`, `mapper`, `model`, `config`, `other`)

- **entities**  
  Business entity candidates extracted from class names  
  (e.g., `Order`, `Stock`, `Sku`, `Inventory`)

- **operations**  
  Business operation candidates extracted from method names  
  (e.g., `createOrder`, `lockStock`, `deductStock`, `cancelOrder`)

- **candidate_flows**  
  Heuristic flow skeletons constructed from operations  
  (e.g., `place_order`, `cancel_and_release`, `pay_callback`)

Each item in the domain map explicitly records its supporting `evidence_chunks`, enabling full traceability back to the source code.

---

## 2. How Representativeness Is Guaranteed

Representativeness is ensured along three orthogonal dimensions:
**architecture layers**, **business objects**, and **execution scenarios**.

### 2.1 Coverage Across Architecture Layers

**Goal:**  
Avoid generating data that focuses only on controllers or only on SQL logic.

**Mechanism:**  
Each code chunk is assigned an architectural layer using `infer_boundary(file_path, content)`.

Layer classification is based on stable engineering conventions:
- path patterns (e.g., `/controller/`, `/service/`, `/mapper/`)
- annotations and class-level signals (e.g., `@RestController`, `@Service`, `@Mapper`)
- configuration file markers (`application.yml`, `@Configuration`)

This logic is defined in `BOUNDARY_RULES`.

**Output:**  
The `boundaries` field in `domain_map.json` records the list of `chunk_id`s for each layer, allowing downstream sampling to explicitly include controller-, service-, and mapper-level evidence.

---

### 2.2 Coverage Across Business Objects (Order / Stock)

**Goal:**  
Ensure both order-related and stock-related logic are covered, including cross-domain interactions.

**Mechanism 1: Domain classification**  
`choose_domain(text)` assigns each chunk to `order`, `stock`, `mixed`, or `other` using keyword voting over `ORDER_KWS` and `STOCK_KWS`.

**Mechanism 2: Entity and operation aggregation**

- **Entities** are extracted from Java class names using `extract_class_names()` and filtered by `is_entity_name()`.
- **Operations** are extracted from Java method names using `extract_method_names()` and filtered by `is_operation_name()`.

For each entity or operation, the pipeline aggregates:
- `evidence_chunks`
- domain distribution and `confidence`
- (for entities) core implementation files via `mentions`

**Output:**  
The `entities` and `operations` sections provide object-centric, domain-aware evidence pools for QA generation.

---

### 2.3 Coverage Across Scenarios (Success / Failure / Boundary)

**Goal:**  
Avoid training data that only reflects “happy paths”.

**Mechanism 1: Operation vocabulary**
The operation filters explicitly include failure and compensation verbs: `cancel`, `refund`, `close`, `release`, `unlock`.

These operations naturally surface error-handling and rollback logic.

**Mechanism 2: Flow skeleton construction**
`build_candidate_flows()` constructs multiple flow skeletons:
- `place_order` (normal execution)
- `cancel_and_release` (compensation / rollback)
- `pay_callback` (external event-driven transition)

Each flow contains step-level `why` annotations and direct `evidence_chunk` references.

**Output:**  
`candidate_flows` acts as an explicit scenario coverage inventory.

---

## 3. Sampling Strategies

The domain map supports three complementary sampling strategies.

### 3.1 Flow-Balanced Sampling

Each `candidate_flow` is treated as a sampling bucket.
Downstream data generation can sample evenly across flows to prevent dominance by a single main process (e.g., order placement).

---

### 3.2 Keyword- and File-Weighted Sampling

- Operations record `signals`, i.e., the most frequently matched   business keywords.
- Entities record `mentions`, i.e., their most frequently referenced files.

These signals allow prioritizing:
- operations with stronger semantic evidence
- files that represent core implementations

This provides a lightweight approximation of “hot code” without relying on call graphs or version control history.

---

### 3.3 State-Oriented Sampling

While explicit state enumeration is performed in later QA-generation steps,
Step02 provides the necessary primitives:
- state-changing operations (`lock`, `deduct`, `release`, `cancel`)
- flow context via `candidate_flows`
- layer context via `boundaries`

This enables systematic enumeration of order and stock states when
constructing questions.

---

## 4. Traceability and Auditability

Every structure in the domain map maintains explicit references to
source code chunks:

- `boundaries` → layer → `chunk_id`
- `entities` → `evidence_chunks`, `mentions`
- `operations` → `evidence_chunks`, `signals`
- `candidate_flows` → step-level `evidence_chunk`

As a result, any generated training sample can be fully audited and
reproduced.

---

## 5. Limitations and Extension Points

**Limitations**
- Domain inference is keyword-based and may miss unconventional naming.
- Java parsing is regex-based and not a full AST.
- Flow skeletons represent conceptual processes, not exact call graphs.

**Extensions**
- Expand keyword lists and boundary rules.
- Introduce additional flow templates (idempotency, retry, timeout).
- Optionally add lightweight intra-file call edges while preserving
  explainability.
