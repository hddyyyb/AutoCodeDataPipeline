# Domain Map Construction

This document explains how AutoCodeDataPipeline constructs an intermediate domain map from the repository.

---

## 1. Purpose

The domain map provides a structured view of:
- Architectural boundaries
- Domain entities
- Business operations
- Candidate execution flows

It serves as the foundation for downstream QA and design generation.

---

## 2. Heuristic but Auditable Approach

The system does not attempt to build a complete call graph.

Instead, it prioritizes:
- Explainability over completeness
- Traceability over precision

Every inferred entity, operation, or flow retains:
- Evidence chunk references
- Confidence scores
- Domain attribution rationale

---

## 3. Architectural Boundaries

Chunks are categorized into:
- controller
- service
- mapper
- model
- config
- other

This enables architecture-aware question generation and design constraints.

---

## 4. Entities and Operations

- Entities answer: “What domain object exists, and where?”
- Operations answer: “What business action is performed, and why?”

Both are grounded in evidence chunks to support downstream explanations.

---

## 5. Candidate Flows

Flows represent **common business skeletons**, not exact call paths.

They answer:
> “Does the repository contain a recognizable business process pattern?”

Each flow includes:
- Ordered steps
- Rationale for each step
- Evidence chunks

## 6. Representativeness and Coverage

The domain map ensures dataset diversity by:
- Covering multiple architectural layers (controller/service/mapper)
- Including both order and inventory domains
- Abstracting multiple execution flows and rule types

This structured intermediate representation enables systematic and extensible data generation.
