# Domain Map Construction

This document explains how AutoCodeDataPipeline constructs an **intermediate domain map** from a local code repository.

The domain map serves as a structured semantic layer between raw source code and downstream training data generation.

---

## 1. Purpose

The domain map provides a structured view of the repository, including:
- Architectural boundaries
- Domain entities
- Business operations
- Candidate execution flows

It is explicitly designed to support the two scenarios required by the assignment:
- Repository-grounded QA generation
- Repository-constrained architecture and design tasks

Rather than generating training data directly from raw code, the domain map enables **systematic, controllable, and extensible** data generation.

---

## 2. Heuristic but Auditable Approach

The system does **not** attempt to build a complete or precise call graph.

This is a deliberate engineering choice:
- Completeness is sacrificed in favor of explainability
- Precision is traded for traceability and controllability

The domain map is intended to answer:
> “What meaningful business structure exists in this repository,
> and where is it implemented?”

To ensure auditability, every inferred element (entity, operation, or flow) retains:
- Evidence chunk references (`chunk_id`)
- Domain attribution rationale
- Confidence or heuristic signals (where applicable)

As a result, all downstream QA and design samples can be traced back
to concrete source code locations.

---

## 3. Architectural Boundaries

Each code chunk is categorized into one of the following architectural roles:
- `controller`
- `service`
- `mapper`
- `model`
- `config`
- `other`

This boundary classification enables:
- Architecture-aware question generation (e.g., service-layer responsibilities)
- Design constraints aligned with existing layering
- Cross-layer reasoning in both QA and design tasks

---

## 4. Entities and Operations

The domain map distinguishes between **entities** and **operations**:

- **Entities** answer the question:  
  *“What domain objects exist, and where are they defined?”*

- **Operations** answer the question:  
  *“What business actions are performed, and why?”*

Both entities and operations are:
- Extracted using heuristic patterns
- Grounded in concrete evidence chunks
- Annotated with domain information

This abstraction allows the system to generate questions and design requirements
that are semantically meaningful rather than syntactically driven.

---

## 5. Candidate Execution Flows

Candidate flows represent **common business skeletons**, not exact execution paths.

They are used to capture recognizable process patterns, such as:
- Order creation and submission
- Inventory reservation and deduction
- State transitions and failure handling

Each flow includes:
- An ordered sequence of conceptual steps
- A rationale explaining why each step exists
- Evidence chunks supporting the step

The domain map answers the key question:
> “Does this repository implement a recognizable business process pattern?”

This is sufficient for generating grounded QA and design tasks, without requiring a fully accurate call graph.

---

## 6. Representativeness and Coverage Guarantees

The domain map is a primary mechanism for ensuring dataset representativeness and diversity **by construction**, rather than by random sampling.

It achieves this by:
- Covering multiple architectural layers (controller / service / mapper)
- Spanning multiple domains (order / inventory / mixed)
- Abstracting multiple entities, operations, and execution flows

Because all downstream samples are generated **from the domain map**:
- No single file or class can dominate the dataset
- Business logic patterns are represented proportionally
- New domains or repositories can be added without redesigning the pipeline

As a result, the domain map enables **systematic, extensible, and balanced** training data generation aligned with real repository structure.
